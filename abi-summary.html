<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="Author" content="Roger Orr">
<title>ABI summary</title>

<style type="text/css">
  body { font-family: sans-serif }
</style>

</head>

<body>

<h2>Table of Contents</h2>
<ol>
<li><a href="#original"> Original statement of the concern </a>
<li><a href="#meta"> Meta Comment </a>
<li><a href="#past"> Past ABI breaks </a>
<li><a href="#implementation"> Implementation related </a>
<li><a href="#deprecation"> Changes with 'deprecation' </a>
<li><a href="#rejected"> Changes rejected because of ABI breaks </a>
<li><a href="#reverted"> Changes reverted because of ABI breaks </a>
<li><a href="#future"> Future ABI breaks </a>
</ol>

<h1 id="original"> 1. Original statement of the concern </h1>
<p>
From Michael Wong's original email to EWG/LEWG:
<p>
There is a concern that we need to be clear on when we can make clear ABI breakage.
There seems to be several cases on a spectrum of Performance vs Stability.
<p>
Cases 1-4:
<ol>
<li>NEVER break ABI : this is the hope and the most stable.
<li>Break ABI on a case by case basis e.g. SSO
<li>Break ABI at key declared boundary releases, e.g.  allow break every 12 years, or every 4 releases
<li>Break ABI at will, e.g. every release, most Performance
</ol><p>
Case 1: NEVER Break ABI leads to slower and slower performance but the best stability<br/>
Case 2: we have done that before, but it is unpredictable to users<br/>
Case 3: We have never tried this before, the question is what is the appropriate time frame between breakage<br/>
Case 4: this is the fastest moving, most performance, and the least stability.

<h1 id="meta"> 2. Meta Comment </h1>

One thing I (Titus) find particularly noteworthy: in the San Diego meeting with its
preponderance of new-attendees and papers from new attendees, we saw a
significant uptick on papers that were dismissed because of ABI concerns.
While that isn't <b>proof</b> of anything, I <b>suspect</b> that there are many ideas
that experienced committee members are filtering early because we have
internalized "that's an ABI break and thus a non-starter."
<p>
I don't have anything on my list that individually feels (even to me) like
"we should break ABI for this" - the most impactful bit in my area would
probably be improvements to hashing. But I <b>suspect</b> that if we plan for it
with enough lead time we'll come up with a lot of quality-of-life and minor
performance improvements that add up to a lot.
<p>
Or, as I've said elsewhere: if we are just going to let "that's an ABI
break" be an automatic veto, we should probably update our published
priorities. I don't think "ABI stability" is listed anywhere as a "you can
rely on this" feature for C++.

<h1 id="past"> 3. Past ABI breaks </h1>

When <code>::operator new()</code> started throwing <code>std::bad_alloc</code>, two binary incompatibilities were introduced:
<ol>
<li> Existing binaries that were not designed to have exceptions propagating through them suddenly had exceptions propagating
   through them 
<li> Existing <code>new_handlers</code> were retroactively made non-conforming
</ol>
Compilers and runtimes incorporated some devious tricks to mitigate the potentially harmful effects of this necessary change.
<p>
The changes to the definition of triviality could potentially have changed calling conventions,
 but to avoid that the Itanium ABI uses the C++98 definition of POD, not the current definition
 of trivial and standard layout, because that's evolved over time.
<p>
Adding the <code>std::system_error</code> base class to <code>std::ios_failure</code> for C++11 was a particularly nasty one for me.
<div style="margin-left: 3em">
(The reason that one's so troublesome is that changing the type of exception thrown by a library doesn't produce any linkage
 changes. You can still link to it as before, but suddenly an exception that used to get caught now passes straight through
 your catch handlers. When a function's return type or parameter type changes, that can be turned into a linker error, so
 the user knows to recompile. Changes to the type of an exception thrown by the standard library (where the throw site is
 not in a header, so the precise type thrown is out of your control) is a silent change in runtime behaviour, and only on
 the exceptional path.
<p>
Buy me a beer some time and I'll tell you the story of Schrödinger's Catch, which allows a single catch handler to work for 
two distinct types of <code>std::ios_failure</code>.
)
</div>
<p>
In C++11 <code>std::char_traits</code> changed the parameter types of its members from <code>const char_type&</code> to passing <code>char_type</code> by value
 (I think we still don't actually implement that in libstdc++).
<p>
I think the LWG issues list records quite a few breaks between C++98 and C++03 that probably wouldn't be acceptable today,
but back then almost nobody actually implemented the full standard anyway, so making breaking changes was just part of
finishing the implementation!
<p>
P0482 (char8_t) changed the return type of the <code>u8string</code> and <code>generic_u8string</code> member functions of
 <code>std::filesystem::path</code> for C++20.

<h1 id="implementation"> 4. Implementation related </h1>

Whether move constructors should affect whether a type is passed in a register or on the stack
<p>
Whether empty class types as function arguments take up a slot in the argument list or not.

<h1 id="deprecation"> 5. Changes with 'deprecation' </h1>

The removal of <code>uncaught_exception</code> wasn't really an ABI break due to zombie names.
<p>
Same for get_unexpected/set_unexpected, etc.

<h1 id="rejected"> 6. Changes rejected because of ABI breaks </h1>

My (Titus') list of papers that have been to LEWG or LEWG-I and rejected (sometimes
without further discussion) because their perceived value <b>individually</b>
didn't measure up to the perceived cost of an ABI break:
<ul>
<li> LEWG 1053 (Unify algorithms with operator and function object variants)
<li> D.7 - remove uncaught_exception?
<li> system_error should return string_view not std::string
<li> heterogenous lookup could be smoother
<li> hashing salt / std::hash optimization (which means standard unordered
   containers are forever vulnerable to hash flooding)
<li> push_back returns T&
<li> int128 / uint128 can't be added (because maxint_t is part of the ABI)
<li> mark bitset trivial?
<li> P1196 (Value-based std::error_category comparison)
<li> P1197 (A non-allocating overload of error_category::message())
<li> P1198 (Adding error_category::failed())
<li> P1249 (allow initializer_list to be of non-const T)
</ul>
<p>
ABI was the reason why we didn't make destructors implicitly virtual in polymorphic classes.  If we can take an ABI break we can fix that.
<p>
Adding new virtual functions to <code>std::num_get</code> and <code>std::num_put</code> was proposed for short float,
but I believe has now been dropped from the proposal.
<p>

<h1 id="reverted"> 7. Changes reverted because of ABI breaks </h1>

The addition of <code>std::default_order</code> to associative containers was reverted because it was an ABI break.
<p>
The change from <code>lock_guard&lt;T&gt;</code> to <code>lock_guard<T...></code> was reverted because it was an ABI break.

<h1 id="future"> 8. Future ABI breaks </h1>

(Not an ABI break taken, but one that should have been (or should be) taken)
<p>
make <code>std::unique_ptr&lt;T&gt;</code> be passed as efficiently as <code>T*</code>. Currently there is
a significant performance and optimization hit from using
<code>std::unique_ptr&lt;T&gt;</code> due to the ABI & calling convention required.
<div style="margin-left: 3em">
Which had the following reply: This is slightly different from, say, <code>list::size</code> and CoW string; there
was no change in the specification that would've caused or prevented
such a passing convention. There's fairly little we could've done in
the standard to impact this.)
</div>
<p>
Numerous aspects of <code>std::unordered_map</code>'s API and ABI force seriously suboptimal implemantation strategies.
(See SwissTable talks.)
<p>
Same for <code>std::map</code>. (For example btree-based sorted containers.)
<p>
The most frustrating for me personally is <code>std::vector</code>, which cannot support small-size-optimization due to stability
of pointers & iterators across move.
<p>
We changed the return type of *<code>::emplace_back</code> from <code>void</code> to return a reference to the new element.
We <i>didn't</i> do the same for <code>push_back</code> because that would have broken ABI.
If we could break ABI we could make them consistent and remove one reason to (ab)use <code>emplace_back</code>.
<div style="margin-left: 3em">
Further discussion
<p>
Is that really a problematic ABI break for some compilers? In gcc-land we might stick an abi_tag on it so
the new version gets a different mangling, but I believe the ABI is not
broken. Unless of course you start introspecting and use
<code>decltype(c.push_back(e))</code>, but that's indirect and seems acceptable. 
<p>
In reply: 
<p>
Without the abi-tag the old and new versions of the function have the same
mangled name.
<p>
One translation unit instantiates the old definition, and in that TU
nothing uses the return value (because it's void).
<p>
Another translation unit instantiates the new definition, and the caller of
the function uses the non-void return values.
<p>
You have two instantiations, with the same symbol name. The linker picks
one. Because it's a Thursday the linker picks the old definition of the
symbol, which doesn't actually return anything. The new TU calls the old
symbol, and there is junk on the stack where it expects to find a return
value. 
<p>
Further reply:
<p>
Thanks. Sorry, my message was not clear enough. I know all that. My point
was that some annotation like abi-tag easily avoids this issue. And you
only need a very basic version of abi-tag for that, which should be easy
to implement for any compiler that cares about binary compatibility. So I
don't think we should refrain from making such changes for ABI reasons.
<p>
Since this is a member function, its exact signature is not mandated by
the standard, so an implementation could also add an extra argument with a
default value, as allowed by [member.functions], to give it a different
mangling. But a vendor-specific annotation is more convenient.
</div>
<p>
Library Fundamentals defines <code>std::packaged_task</code> and <code>std::promise</code> with polymorphic allocator members,
which adds a pointer member to the class. That was originally proposed as a change to the standard types when LFTS was enabled,
which would have been an ABI break. Instead the types in LFTS are distinct types in a distinct namespace.
<p>
LWG 2503 "multiline option should be added to syntax_option_type" is an ABI break.

</body>